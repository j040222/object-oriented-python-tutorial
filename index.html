 <!DOCTYPE html>
<html lang="en">
   <meta charset="UTF-8">
   <title>Object-Oriented Python Tutorial</title>
   <meta name="viewport" content="width=device-width,initial-scale=1">
   
   <link rel="stylesheet" href="./styles.css">
   <link
      rel="stylesheet"
      type="text/css"
      href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.5.0/semantic.min.css"
      >
   <link
      rel="stylesheet"
      type="text/css"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css"
      >
   
   <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous">
   </script>
   <script
      src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.5.0/semantic.min.js"
      >
   </script>
   <script
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"
      >
   </script>
   
   <body>
      <div class="content-column">
         <h1>Object-Oriented Python Tutorial</h1>
         
         <br/>
         
         <p>
         Tutorials and examples of object-oriented python3
         features.
         </p>
         
         <br/>
         
         <p><i class="angle right icon"></i>Contents</p>
         
         <div class="toc">
            
            <div class="toc-item">
               <a href="#using_classes">
                  Using Classes
               </a>
            </div>
            <div class="toc-item">
               <a href="#function_syntax">
                  Function Syntax
               </a>
            </div>
            <div class="toc-item">
               <a href="#lambda_functions">
                  Lambda Functions
               </a>
            </div>
            <div class="toc-item">
               <a href="#comprehension">
                  List and Dictionary Comprehension, and
                  Context Managers
               </a>
            </div>
            <div class="toc-item">
               <a href="#virtual_environments">
                  Virtual Environments
               </a>
            </div>
            <div class="toc-item">
               <a href="#packages">
                  Wheels and Source Packages
               </a>
            </div>
            
            <div class="toc-item">
               <a href="#the_builtin_functions">
                  Select Builtin Functions
               </a>
            </div>
            <table>
               <tr>
                  <td>
            
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__abs">
                  abs
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__all">
                  all
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__any">
                  any
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__bin">
                  bin
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__bool">
                  bool
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__breakpoint">
                  breakpoint
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__bytearray">
                  bytearray
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__bytes">
                  bytes
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__callable">
                  callable
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__chr">
                  chr
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__classmethod">
                  classmethod
               </a>
            </div>
            
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__compile">
                  compile
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__complex">
                  complex
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__delattr">
                  delattr
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__dict">
                  dict
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__dir">
                  dir
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__divmod">
                  divmod
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__enumerate">
                  enumerate
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__eval">
                  eval
               </a>
            </div>
                  </td>
                  <td>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__exec">
                  exec
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__filter">
                  filter
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__float">
                  float
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__format">
                  format
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__fronzenset">
                  fronzenset
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__getattr">
                  getattr
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__globals">
                  globals
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__hasattr">
                  hasattr
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__hash">
                  hash
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__help">
                  help
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__hex">
                  hex
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__id">
                  id
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__input">
                  input
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__int">
                  int
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__isinstance">
                  isinstance
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__issubclass">
                  issubclass
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__iter">
                  iter
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__len">
                  len
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__list">
                  list
               </a>
            </div>
                  </td>
                  <td>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__locals">
                  locals
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__map">
                  map
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__max">
                  max
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__min">
                  min
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__next">
                  next
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__object">
                  object
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__oct">
                  oct
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__open">
                  open
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__ord">
                  ord
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__pow">
                  pow
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__print">
                  print
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__property">
                  property
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__range">
                  range
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__repr">
                  repr
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__reversed">
                  reversed
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__round">
                  round
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__set">
                  set
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__setattr">
                  setattr
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__slice">
                  slice
               </a>
            </div>
                  </td>
                  <td>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__sorted">
                  sorted
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__staticmethod">
                  staticmethod
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__str">
                  str
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__sum">
                  sum
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__super">
                  super
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__tuple">
                  tuple
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__type">
                  type
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__vars">
                  vars
               </a>
            </div>
            <div class="toc-item toc-level-1">
               <a href="#the_builtin_functions__zip">
                  zip
               </a>
            </div>
            <div
               class="toc-item toc-level-1"
               style="min-width:1em; min-height:24em"
               >
            </div>
                  </td>
               </tr>
            </table>
            
            <div class="toc-item">
               <a href="#operator_overloading">
                  Operator Overloading
               </a>
            </div>
            <div class="toc-item">
               <a href="#closures">
                  Closures
               </a>
            </div>
            <div class="toc-item">
               <a href="#generators">
                  Generators
               </a>
            </div>
            <div class="toc-item">
               <a href="#coroutines">
                  Coroutines
               </a>
            </div>
            <div class="toc-item">
               <a href="#decorators">
                  Decorators
               </a>
            </div>
            <div class="toc-item">
               <a href="#properties">
                  Properties
               </a>
            </div>
            <div class="toc-item">
               <a href="#serialization">
                  Serialization / Marshalling / Pickling
               </a>
            </div>
            
         </div>
         
         <h2 id="using_classes">
            Using Classes
         </h2>
         
         <p>
         Classes are defined as follows:
         </p>
         
         <pre><code class="language-python">class Class:
   """Documentation for Class"""
   
   #
   # A class variable:
   #
   
   static_value_ = 12
   
   def __init__(self):
      #
      # An instance variable:
      #
      self.value_ = 456
   
   def function(self):
      return self.value_</code></pre>
         
         <p>
         To create an instance of a class:
         </p>
         
         <pre><code class="language-python">obj = Class()</code></pre>
         
         <p>
         To call a class function:
         </p>
         
         <pre><code class="language-python">print(obj.function())</code></pre>
         
         <p>
         Class attributes can be accessed and modified
         without instances:
         </p>
         
         <pre><code class="language-python">Class.static_value_ = 123
print(obj.static_value_)                  # 123, not 12</code></pre>
         
         <p>
         <constant_name>__doc__</constant_name> is a valid
         attribute. It returns the documentation string
         associated with the class:
         </p>
         
         <pre><code class="language-python">print(obj.__doc__)
print(Class.__doc__)</code></pre>
         
         <p>
         Data members (like
         <constant_name>obj.value_</constant_name>) are
         called 'data attributes' in python. Function
         instance attributes are called 'methods'.
         </p>
         
         <p>
         The expression
         <function_name>obj.function()</function_name>
         implicitly binds
         <constant_name>self</constant_name>, so it is
         equivalent to these expressions:
         </p>
         
         <pre><code class="language-python">print( Class.function(obj) )

f = obj.function
print( f() )</code></pre>
         
         <p>
         Methods can be assigned after instantiation and can
         be defined outside of the class. However,
         <constant_name>self</constant_name> is only
         implicitly bound for function class attributes:
         </p>
         
         <pre><code class="language-python">def function1(self, x):
   return x

obj.function1 = function1

print( obj.function1(obj, 1) )            # 1

class Class2:
   f = function1                          # binds 'self'

c = Class2()
print( c.f(1) )                           # 1</code></pre>
         
         <p>
         Classes can inherit other classes, override base
         class functions, and call base class functions
         using <function_name>super()</function_name>:
         </p>
         
         <pre><code class="language-python">class A:
   def f(self, x):
      return (x + 1)

class B(A):
   def f(self, x):                        # An override
      return x
   
   def g(self, x):
      return super().f(x)                 # or A.f(self)

b = B()
print( b.f(1) )                           # 1, not 2
print( b.g(1) )                           # 2, not 1</code></pre>
         
         <p>
         Multiple inheritance is also allowed:
         </p>
         
         <pre><code class="language-python">class A:
   def f(self):
      return 1

class B():
   def f(self):
      return 2

class C(A,B):
   pass</code></pre>
         
         <p>
         If functions with the same name are defined in
         multiple base classes, the first base class in the
         class argument list is called:
         </p>
         
         <pre><code class="language-python">c = C()
print( c.f() )                            #  1
</code></pre>
         
         <p>
         <function_name>Super</function_name> calls the next
         class upward in the
         <constant_name>method resolution order</constant_name>,
         which is the order in which overridden methods are
         resolved in inheriting classes:
         </p>
         
         <pre><code class="language-python">class A():
   def f(self):
      super().f()
      print("A.f")

class B():
   def f(self):
      print("B.f")

class C(A,B):
   def f(self):
      super().f()
      print("C.f")

c = C()
print(C.__mro__)                          # The MRO is C -> A -> B
c.f()                                     # Calls C.f -> A.f -> B.f</code></pre>
         
         <p>
         All methods in python are effectively virtual.
         So base classes can call derived class methods:
         </p>
         
         <pre><code class="language-python">class A():
   def f(self):
      self.g()                            # Allowed when B inherits A

class B(A):
   def g(self):
      print("g")

b = B()
b.f()</code></pre>
         
         <p>
         Use <function_name>isinstance</function_name> to
         check whether an object
         (eg. <constant_name>b</constant_name>)
         is an instance of a class (by inheritance or
         otherwise).
         Use <function_name>issubclass</function_name> to
         check whether a class is derived from another
         (including, possibly, itself):
         </p>
         
         <pre><code class="language-python">print(isinstance(b, A))                   # True
print(issubclass(B, A))                   # True
print(issubclass(A, A))                   # Also true</code></pre>
         
         <p>
         If a class (<constant_name>A</constant_name>)
         appears more than once in the hierarchy of another
         (<constant_name>C</constant_name>) then it still
         only appears once in the
         <constant_name>MRO</constant_name>:
         </p>
         
         <pre><code class="language-python">class A(object):
   pass

class B(A):
   pass

class C(A):
   pass

class D(B, C):
   pass

print(D.__mro__)                          # Contains A only once</code></pre>
         
         <p>
         By convention, attributes beginning with
         <constant_name>_</constant_name> are
         considered private implementation details (and
         subject to change):
         </p>
         
         <pre><code class="language-python">class A:
   _private = 123                         # Not quite "private"</code></pre>
         
         <p>
         Name mangling. Class attributes that begin with
         <constant_name>__</constant_name> (and which have
         no more than 1 trailing underscore) are
         automatically replaced with the prefix
         <constant_name>_classname__</constant_name>.
         </p>
         
         <pre><code class="language-python">class A:
   __attribute = 123
   
   def f(self):
      print(self.__attribute)             # Allowed

# print(A.__attribute)                    # A.__attribute not found
print(A._A__attribute)                    # 123

a = A()
a.f()                                     # Allowed - 123</code></pre>
         
         <p>
         Python provides several special builtin attributes
         as follows:
         </p>
         
         <pre><code class="language-python">class A(object):
   def f(self):
      pass

class B(A):
   def g(self):
      pass

b = B()</code></pre>
         
         <p>
         A dictionary of b's (writeable) attributes:
         </p>
         
         <pre><code class="language-python">print(b.__dict__)</code></pre>
         
         <p>
         The name of the class of
         <constant_name>b</constant_name>:
         </p>
         
         <pre><code class="language-python">print(b.__class__)</code></pre>
         
         <p>
         A tuple of the base classes of
         <constant_name>B</constant_name>:
         </p>
         
         <pre><code class="language-python">print(B.__bases__)</code></pre>
         
         <p>
         The name of <constant_name>B</constant_name>:
         </p>
         
         <pre><code class="language-python">print(B.__name__)</code></pre>
         
         <p>
         The qualified name of
         <constant_name>B</constant_name>:
         </p>
         
         <pre><code class="language-python">print(B.__qualname__)</code></pre>
         
         <p>
         The method resolution order of
         <constant_name>B</constant_name>:
         </p>
         
         <pre><code class="language-python">print(B.__mro__)</code></pre>
         
         <p>
         The subclasses of <constant_name>B</constant_name>:
         </p>
         
         <pre><code class="language-python">print(B.__subclasses__)</code></pre>
         
         
         <h2 id="function_syntax">
            Function Syntax
         </h2>
         
         <p>
         When calling a function, arguments can be specified
         using their names in the function signature:
         </p>
         
         <pre><code class="language-python">def f(first, second):
   print(first, second)

f(first="Hello", second="World!")         #  "Hello World!"</code></pre>
         
         <p>
         Keyword arguments can be specified in any order:
         </p>
         
         <pre><code class="language-python">f(second="World!", first="Hello")         #  The same</code></pre>
         
         <p>
         Keyword arguments must follow positional arguments:
         </p>
         
         <pre><code class="language-python">f("Hello", second="World!")               #  "Hello World!"</code></pre>
         
         <p>
         *args will give all positional arguments as a
         tuple:
         </p>
         
         <pre><code class="language-python">def f(*args):
   for arg in args:
      print(arg, end=' ')
   print()

f("Hello", "World!")                      #  "Hello World!"</code></pre>
         
         <p>
         ** will give all keyword arguments as a dict:
         </p>
         
         <pre><code class="language-python">def f(**args):
   for key, value in args.items():
      print(value, end=' ')
   print()

f(first="Hello", second="World!")         #  "Hello World!"</code></pre>
         
         <p>
         Both can be combined:
         </p>
         
         <pre><code class="language-python">def f(arg0, arg1, *args, **kwargs):
   print(arg0, arg1, args, kwargs)
   print()

f("Hello", "World!", "This", "is", first="Mars")
            #  Hello World! ('This', 'is') {'first': 'Mars'}</code></pre>
         
         <p>
         * and ** can also be used when calling functions.
         In this case, * unpacks a list or a tuple and **
         unpacks a dict into an array of keyword arguments:
         </p>
         
         <pre><code class="language-python">def f(*args):
   for arg in args:
      print(arg, end=' ')
   print()

f( *["Hello", "World!"] )                 #  "Hello World!"
f( *("Hello", "World!") )                 #  "Hello World!"

def f(**args):
   for key, value in args.items():
      print(value, end=' ')
   print()

f( **{ 'first':"Hello", 'second':"World!" } )</code></pre>
         
         <p>
         In python3, * can also be used on the left hand
         side of an assignment operation. For example:
         </p>
         
         <pre><code class="language-python">first, *others = [1,2,3]
print(others)                             #  [2,3]</code></pre>
         
         <p>
         * can also be used by itself in a function argument
         list. In this case, it means that all arguments
         after the * must be keyword (named) arguments:
         </p>
         
         <pre><code class="language-python">def f(first, second="World!", *, rest):
   print(first, second, rest, end='')
   print()

f("Hello", rest="This is Mars")</code></pre>
         
         <p>
         The return value of functions can be annoted
         using <constant_name>-&gt;</constant_name> as
         follows:
         </p>
         
         <pre><code class="language-python">def f(x) -> "The same value as the input":
   return x</code></pre>
         
         <p>
         The annotation following
         <constant_name>-&gt;</constant_name> can be
         accessed using
         <constant_name>f.__annotations__['return']</constant_name>:
         </p>
         
         <pre><code class="language-python">print(f.__annotations__)</code></pre>
         
         <p>
         The annotation need not be a string:
         </p>
         
         <pre><code class="language-python">def f(x) -> { 'doc':"The same value as the input", 'type':int } :
   return x

print(f.__annotations__['return'])</code></pre>
         
         
         <h2 id="lambda_functions">
            Lambda Functions
         </h2>
         
         <p>
         Lambda functions can accept any number of arguments
         and can be named. Lambdas can also be passed as
         arguments to other functions.
         </p>
         
         <p>
         Lambda functions should consist of one expression
         only. Multiple expressions/lines are not allowed.
         Lambda functions cannot contain statements.
         Including statements like
         <constant_name>return</constant_name>,
         <constant_name>assert</constant_name> and
         <constant_name>raise</constant_name>
         will cause a
         <constant_name>SyntaxError</constant_name>
         exception. There is no equivalent for type hinting
         (<constant_name>-&gt;</constant_name>) with lambda
         functions, and you cannot decorate a lambda
         function using the
         <constant_name>@decorator</constant_name> syntax.
         </p>
         
         <pre><code class="language-python">f = lambda x : x                          #  Identity

print(f(1))                               #  1

f = lambda a, b, c : (a + b + c)

print(f(1,2,3))                           #  6

def f(g):
   return g

f(lambda x : print(x)) (1)                #  1</code></pre>
         
         <p>
         Assign a custom docstring to a lambda function:
         </p>
         
         <pre><code class="language-python">f.__doc__ = "A documentation string"
print(f.__doc__)</code></pre>
         
         <p>
         There is very little difference between a function
         and a lambda function. Note, however, that lambda
         functions are not named in tracebacks:
         </p>
         
         <pre><code class="language-python">f = lambda x : x / 0
# f(1)                                    #  Error: 1/0

print(f.__name__)                         #  &lt;lambda&gt;</code></pre>
         
         <p>
         Lambda function arguments can be named (Ie. they
         can be keyword arguments) and varargs is allowed:
         </p>
         
         <pre><code class="language-python">f = lambda a,b : (a + b)
print(f(b=1, a=2))                        #  3
print(f( *[1,2] ))                        #  3
print(f( **{ 'a':1, 'b':2 } ))            #  3

f = lambda **kwargs : sum(kwargs.values())
print(f(first=1, second=2))               #  3</code></pre>
         
         <p>
         Like regular functions, a lambda function can also
         be a closure:
         </p>
         
         <pre><code class="language-python">def f(x):
   y = 1
   return lambda z : (x + y + z)

g = f(1)
print(g(1))                               #  3</code></pre>
         
         <p>
         In Python, lambda closure functions bind their
         arguments at execution time, not a definition time.
         This means that using a lambda as a closure in a
         loop can have unexpected effects:
         </p>
         
         <pre><code class="language-python">functions = []
for i in range(3):
   functions.append(lambda : print(i))
for f in functions:
   f()                                    #  2 2 2, not 0 1 2</code></pre>
         
         <p>
         Define the argument with a default value to
         overcome this:
         </p>
         
         <pre><code class="language-python">functions = []
for i in range(3):
   functions.append(lambda x=i : print(x))
for f in functions:
   f()                                    #  0 1 2</code></pre>
         
         <p>
         Class functions and class properties can be
         assigned using lambda functions. However, this
         practice is discouraged:
         </p>
         
         <pre><code class="language-python">class A:
   def __init__(self, number):
      self._number = number
   number =                                                \
      property(
         lambda self : self._number,
         lambda self, value : setattr(self, '_number', value)
         )
   __str__ = lambda self : str(self.number)

a = A(1)
a.number = 2
print(a.number)                           #  2</code></pre>
         
         
         <h2 id="comprehension">
            List and Dictionary Comprehension, and
            Context Managers
         </h2>
         
         <p>
         Lists can be created and populated with the
         following syntax:
         
            <div style="width:5em; display:inline-block"></div>
            <constant_name>(expression) (x)</constant_name> for
            <constant_name>x</constant_name> in
            <constant_name>(iterable)</constant_name>
            
            <br/>
            or:
            <br/>
            
            <div style="width:5em; display:inline-block"></div>
            <constant_name>(expression) (x)</constant_name> for
            <constant_name>x</constant_name> in
            <constant_name>(iterable)</constant_name> if
            <constant_name>(condition)</constant_name>
         </p>
         
         <pre><code class="language-python">a = [ 1,2,3,4,5,6 ]
b = [ x for x in a ]                      #  The same as a
print(b)

b = [ x for x in a if x % 2 == 0 ]        #  Even entries only
print(b)</code></pre>
         
         <p>
         Tuples and other iterables can also be used:
         </p>
         
         <pre><code class="language-python">a = ( 1,2,3,4,5,6 )
b = [ x for x in a if x % 2 == 0 ]        #  Even entries only
print(b)</code></pre>
         
         <p>
         List comprehension can also be used to map list
         values:
         </p>
         
         <pre><code class="language-python">a = 'abc'
b = ''.join( [ x.upper() for x in a ] )   #  Capitalize entries
print(b)                                  #  ABC</code></pre>
         
         <p>
         Note that
         <constant_name>(expression)</constant_name> can
         also contain a condition:
         </p>
         
         <pre><code class="language-python">a = 'abcdef'
b = ''.join( [ x.upper() if ord(x) % 2 == 0 else x for x in a ] )
                                          #  Capitalize every other
                                          #  letter
print(b)                                  #  aBcDeF</code></pre>
         
         <p>
         Dictionaries can also be created and populated
         using the following syntax:
         
            <div style="width:5em; display:inline-block"></div>
            <constant_name>(key)</constant_name> :
            <constant_name>(value)</constant_name> for
            <constant_name>x</constant_name> in
            <constant_name>(iterable)</constant_name>
            
            <br/>
            or
            <br/>
            
            <div style="width:5em; display:inline-block"></div>
            <constant_name>(key)</constant_name> :
            <constant_name>(value)</constant_name> for
            <constant_name>x</constant_name> in
            <constant_name>(iterable)</constant_name> if
            <constant_name>(condition)</constant_name>
         </p>
         
         <pre><code class="language-python">a = { 'first':1, 'second':2, 'third':3, 'fourth':4 }
b = { k:v for (k,v) in a.items() if v % 2 == 0 }
print(b)                                  #  Even values only</code></pre>
         
         <p>
         Multiple <function_name>if</function_name>
         conditions are allowed:
         </p>
         
         <pre><code class="language-python">b = { k:v for (k,v) in a.items() if v % 2 == 0 if v < 3 }
print(b)                                  #  {'second': 2}</code></pre>
         
         <p>
         A custom <function_name>context manager</function_name>
         (for use with the
         <function_name>'with'</function_name>
         keyword) can be created as follows. Declare a class
         with an <constant_name>__enter__</constant_name>
         and an <constant_name>__exit__</constant_name>
         function:
         </p>
         
         <pre><code class="language-python">class A:
   def __enter__(self):
      print("initializing");
   def __exit__(self, type, value, traceback):
      print("closing")

with A() as a:
   print("working")</code></pre>
         
         <p>
         <constant_name>a.__enter__</constant_name> is
         called when the context manager is
         initialized (before "working").
         <constant_name>__exit__</constant_name> is called
         when the context manager terminates (after
         "working"). If an exception occurs,
         <constant_name>__exit__</constant_name>
         receives the type, value and traceback of the
         exception as arguments:
         </p>
         
         <pre><code class="language-python">import traceback

class A:
   def __enter__(self):
      print("initializing");
   def __exit__(self, type, value, traceback):
      #
      # Type: RuntimeError, value: the exception object,
      # traceback: a traceback at the exception site.
      #
      print(type, value, traceback)
      print("closing")
      #
      # If __exit__ returns True, the exception is captured
      # and the with statement will terminate normally. In
      # this case, the exception is 'handled':
      #
      return True

with A() as a:
   print("working")
   raise RuntimeError("exception")</code></pre>
         
         <p>
         Context managers can also be created using
         <function_name>contextlib</function_name> and the
         <function_name>@contextmanager</function_name>
         decorator:
         </p>
         
         <pre><code class="language-python">from contextlib import contextmanager

@contextmanager
def create_cm():
   value = 1
   try:
      yield value
   finally:
      pass

with create_cm() as a:
   print(a)                                  #  1</code></pre>
         
         
         <h2 id="virtual_environments">
            Virtual Environments
         </h2>
         
         <p>
         Virtualenv ('<constant_name>venv</constant_name>')
         is a very useful python feature. A 'virtual
         environment' is an isolated environment for
         <constant_name>pip</constant_name>. Installing (or
         removing) packages in the virtual environment does
         not affect installed packages in the parent (non-virtual) environment.
         </p>
         
         <p>
         To install
         <constant_name>virtualenv</constant_name>
         for your python distribution on linux, type:
         <function_name>sudo apt-get install
         python3.10-venv</function_name>. On Windows using
         IDLE, type:
         <function_name>py -m pip install --user virtualenv</function_name>.
         </p>
         
         <p>
         To create and enter a virtual environment on Linux,
         use
         <constant_name>venv</constant_name> as follows:
         </p>
         
         <pre><code class="language-bash">$ python3 -m venv ./virtual_environment/

$ source ./virtual_environment/bin/activate</code></pre>
         
         <p>
         On Windows, using Powershell:
         </p>
         
         <pre><code class="language-python">.\virtual_environment\Scripts\Activate.ps1</code></pre>
         
         <p>
         Installing packages in the virtual environment does
         not affect installed packages in the parent (non-virtual) environment. Use pip in the virtual environment as follows:
         </p>
         
         <pre><code class="language-bash">$ pip install (package_name)</code></pre>
         
         <p>
         Typing 'which python' will show that the python
         interpreter for the virtual environment is a member
         of <function_name>./virtual_environment</function_name>,
         not the system directories:
         </p>
         
         <pre><code class="language-bash">$ which python</code></pre>
         
         <p>
         To exit the virtual environment, type 'deactivate':
         </p>
         
         <pre><code class="language-python">deactivate</code></pre>
         
         <p>
         To create a <i>requirements file</i> from python scripts
         in the current directory, install and use
         <constant_name>pipreqs</constant_name>
         as follows:
         </p>
         
         <pre><code class="language-python">$ pip install pipreqs

$ pipreqs .</code></pre>
         
         <p>
         To load the requirements file (install the
         packages it contains):
         </p>
         
         <pre><code class="language-python">pip install -r ./requirements.txt</code></pre>
         
         <p>
         A virtual environment for python can also be
         created using <constant_name>conda</constant_name>:
         <a href="https://docs.conda.io/en/latest/">
         https://docs.conda.io/en/latest/
         </a>.
         </p>
         
         
         <h2 id="packages">
            Wheels and Source Packages
         </h2>
         
         <p>
         Python packages are normally distributed
         using
         <constant_name>PyPI</constant_name>
         (the 'Python Package Index'). Packages
         can be distributed in source form or in a binary
         form called a <constant_name>wheel</constant_name>.
         </p>
         
         <p>
         In this example we will create a package that can
         be used as a module or via the command line. To
         create a package containing a single function,
         do the following. Firstly, create an empty
         directory
         named <function_name>custom_package</function_name>
         and then add a file named
         <function_name>custom_package.py</function_name> to
         it containing the following code:
         </p>
         
         <pre><code class="language-python">def increment_number(x):
   """Increment the input number by 1"""
   return (x + 1)

import argparse
from argparse import RawTextHelpFormatter

if __name__ == '__main__':
   
   #
   # Parse arguments:
   #
   
   parser =                                                \
      argparse.ArgumentParser                              \
         (
         formatter_class=RawTextHelpFormatter
         )
   
   parser.add_argument                                     \
      (
      "--input",
      type=int,
      required=True,
      help="The integer to increment"
      )
   
   args = parser.parse_args()
   
   input_number = args.input
   
   print(increment_number(input_number))
   
   exit(0)</code></pre>
         
         <p>
         <constant_name>argpase</constant_name> (and a
         <constant_name>__name__ == '__main__'
         </constant_name> segment) have
         been added after the function named
         <function_name>increment_number</function_name> so
         that the above script can be used at the command
         line as follows:
         </p>
         
         <div class="command_line">python3 ./custom_package.py --input 2</div>
         <div class="program_output">3</div>
         
         <p>
         Now create the following files:
         </p>
         
         <p>
         1. An empty text file named
         <constant_name>__init__.py</constant_name>
         </p>
         
         <p>
         2. A text file named
         <constant_name>MANIFEST.in</constant_name>
         containing one source file per line, using
         <a href="https://packaging.python.org/en/latest/guides/using-manifest-in/#manifest-in-commands">this syntax</a>:
         </p>
         
         <div class="text_file">include custom_package.py</div>
         
         <p>
         3. A <function_name>toml</function_name> file named
         <constant_name>pyproject.toml</constant_name>:
         </p>
         
         <div class="text_file">[build-system]
requires = [
    "setuptools>=68"
]

build-backend = "setuptools.build_meta"</div>
         
         <p>
         4. A <function_name>.cfg</function_name> file named
         <constant_name>setup.cfg</constant_name> containing
         static metadata for the package:
         </p>
         
         <div class="text_file">[metadata]
name = CustomWheel
version = 0.0.1

description = Example of a custom python3 wheel
long_description = Increments a number
license = GPLv3</div>
         
         <p>
         5. A python script named
         <constant_name>setup.py</constant_name> containing
         the following lines:
         </p>
         
         <div class="text_file">from distutils.core import setup

setup(name='custom_package',
      version='1.0',
      py_modules=['custom_package'],
      )</div>
         
         <p>
         <constant_name>MANIFEST.ln</constant_name> specifies 
         <a href="https://packaging.python.org/en/latest/guides/using-manifest-in/">which files should be
         included</a> in the source distribution of your
         package.
         <constant_name>pyproject.toml</constant_name>
         <a href="https://pip.pypa.io/en/stable/reference/build-system/pyproject-toml/">contains the build system requirements</a>
         (packages required by the builder) and information,
         to be used by pip to build the package.
         <constant_name>setup.cfg</constant_name> contains
         static metadata about the project, for example its
         version number and a textural description of it.
         <constant_name>setup.py</constant_name> contains
         <a href="https://docs.python.org/3/distutils/setupscript.html">instructions to be executed</a> when
         building and installing your project. This normally
         consists of a single call to
         <function_name>distutils.setup</function_name>.
         <constant_name>__init__.py</constant_name> tells
         python that the directory containing
         <constant_name>custom_package.py</constant_name>
         contains a package.
         </p>
         
         <p>
         To create a source distribution, type:
         </p>
         
         <div class="command_line">python setup.py sdist --formats=gztar,zip</div>
         
         in the project directory. This will create a
         subdirectory named
         <function_name>dist/</function_name> that contains
         a
         <constant_name>custom_package-1.0.tar.gz</constant_name>
         file containing the source distribution.
         <a href="#virtual_environments">Create a virtual environment</a>
         and decompress the
         <constant_name>tar.gz</constant_name> file using:
         
         <div class="command_line">tar -xvf ./custom_package-1.0.tar.gz</div>
         
         <div class="program_output">custom_package-1.0/
custom_package-1.0/PKG-INFO
custom_package-1.0/custom_package.py
custom_package-1.0/setup.cfg
custom_package-1.0/setup.py</div>
         
         <p>
         This will create a directory named
         <constant_name>custom_package-1.0/</constant_name>
         containing the packaged source files. Navigate to
         that directory and install the package as follows:
         </p>
         
         <div class="command_line">python setup.py install</div>
         
         <p>
         This will install the source files in the
         subdirectory
         <function_name>lib/python3.10/site-packages</function_name>
         of your virtual environment. Run that file as
         usual:
         </p>
         
         <div class="command_line">python virtual_environment/lib/python3.10/site-packages/custom_package.py --input 2</div>
         
         <div class="program_output">3</div>
         
         <p>
         To create a wheel, install the
         <constant_name>build</constant_name> package and
         run python as follows:
         </p>
         
         <div class="command_line">pip install build
python3 -m build --wheel</div>
         
         <p>
         This will create a wheel file named
         <constant_name>custom_package-1.0*.whl</constant_name>
         in the subdirectory
         <function_name>dist/</function_name>.
         <a href="#virtual_environments">Create a virtual environment</a>
         and load the wheel using
         <constant_name>pip</constant_name> as follows:
         </p>
         
         <div class="command_line">pip install ./custom_package-1.0-py3-none-any.whl</div>
         
         <p>
         The name of the wheel file may differ on your
         system. Now enter the python interpreter and load
         and use the package:
         </p>
         
         <div class="command_line">python
import custom_package
print(custom_package.increment_number(2))</div>
         
         <div class="program_output">&gt;&gt;&gt; print(custom_package.increment_number(2))
3</div>
         
         <h2 id="the_builtin_functions">
            Select Builtin Functions
         </h2>
         
         <p id="the_builtin_functions__abs">
         <function_name>abs(x)</function_name> returns the
         absolute value of an integer or a floating point
         number, the magnitude of a complex number, or
         <function_name>x.__abs__</function_name> if it
         implements it:
         </p>
         
         <pre><code class="language-python">class A:
   value_ = 1
   def __abs__(self):
      return 1

a = A()
print(abs(a))                             #  1</code></pre>
         
         <p id="the_builtin_functions__all">
         <function_name>all()</function_name> compares all
         of the elements of an iterable to
         <constant_name>True</constant_name>. It returns
         <constant_name>False</constant_name> if at least 
         one such test failed:
         </p>
         
         <pre><code class="language-python">x = [ True, True, False ]
print(all(x))                             #  False</code></pre>
         
         <p id="the_builtin_functions__any">
         <function_name>any()</function_name> compares all 
         of the elements of an iterable to
         <constant_name>True</constant_name>. It returns
         <constant_name>False</constant_name> if all such
         tests failed:
         </p>
         
         <pre><code class="language-python">print(any(x))                             #  True</code></pre>
         
         <p>
         <function_name>ascii</function_name> is as
         <function_name>repr</function_name>, except that
         <function_name>ascii()</function_name> escapes all
         non-ASCII characters in the string returned by
         <function_name>repr()</function_name>:
         </p>
         
<pre><code class="language-python">class A:
   value_ = 1
   def __repr__(self):
      return str(self.value_)

a = A()
print(ascii(a))                           #  1
print(repr(a))                            #  1</code></pre>
         
         <p id="the_builtin_functions__bin">
         <function_name>bin(x)</function_name> returns the
         binary representation of an integer, or the binary
         representation of
         <function_name>x.__index__</function_name> if it
         exists and if it returns an integer:
         </p>
         
         <pre><code class="language-python">class A:
   value_ = 1
   def __index__(self):
      return self.value_

a = A()
print(bin(a))                             #  0b1
# print(bin(1.0))                         #  floats not allowed</code></pre>
         
         <p id="the_builtin_functions__bool">
         <function_name>bool</function_name> returns a
         boolean by testing the truth value of its argument.
         An object is considered to be
         <constant_name>True</constant_name> unless its class
         defines <function_name>__bool__</function_name>
         (returning <constant_name>False</constant_name>) or
         a <function_name>__len__</function_name> method
         that returns 0:
         </p>
         
         <pre><code class="language-python">x = bool(True)
print(x)                                  #  True

class A:
   def __bool__(self):
      return False

a = A()
print(bool(a))                            #  False</code></pre>
         
         <p id="the_builtin_functions__breakpoint">
         Enter the debugger (pdb) at this line, unless
         <constant_name>PYTHONBREAKPOINT=0</constant_name>
         (a shell variable):
         </p>
         
         <pre><code class="language-python"># breakpoint()                            #  Enter debugger</code></pre>
         
         <p id="the_builtin_functions__bytearray">
         A bytearray is an array of bytes. It is a mutable
         sequence of integers in the range 0 <= x <= 255.
         Being a mutable, it supports slicing and array
         indexing:
         </p>
         
         <pre><code class="language-python">primes = [2,3,5,7,11]
a = bytearray(primes)
print(a)</code></pre>
         
         <p>
         To create a bytearray from a string you must
         specify the encoding:
         </p>
         
         <pre><code class="language-python">a = bytearray("a string", "ascii")
print(a)
print(a[0])                               #  97</code></pre>
         
         <p id="the_builtin_functions__bytes">
         <function_name>bytes()</function_name> creates an
         immutable bytearray:
         </p>
         
         <pre><code class="language-python">a = bytes("a string", "ascii")
a[0] = 98                                 #  Disallowed</code></pre>
         
         <p id="the_builtin_functions__callable">
         <function_name>callable()</function_name> returns
         <constant_name>True</constant_name> if an object
         appears to be callable. Otherwise it returns
         <constant_name>False</constant_name>. Classes are
         callable. Class instances are callable if they
         define
         <constant_name>__call__</constant_name>
         (in which case they have operator()).
         </p>
         
         <pre><code class="language-python">class A:
   def __call__(self):
      print("Callable")

a = A()
print(callable(A))                        #  True
print(callable(a))                        #  True: a() exists</code></pre>
         
         <p id="the_builtin_functions__chr">
         <function_name>chr(x)</function_name> returns the
         string representation of the unicode code point
         <constant_name>x</constant_name>.
         For example, chr(97) is 'a' (because the ascii code
         point of 'a' is 97).
         </p>
         
         <pre><code class="language-python">print(chr(97))                            #  'a'</code></pre>
         
         <p id="the_builtin_functions__classmethod">
         <function_name>@classmethod</function_name>
         modifies class methods so that the first argument
         is the class, not 'self'.
         <function_name>@classmethod</function_name> 
         functions can be called using only the
         class name (and also using instances):
         </p>
         
         <pre><code class="language-python">class A:
   @classmethod
   def f(cls, x):
      print(x)

A.f(1)                                    #  1
A().f(1)                                  #  1</code></pre>
         
         <p id="the_builtin_functions__compile">
         <function_name>compile()</function_name> compiles a
         string (which may or may not come from a file) into
         executable code. Use
         <function_name>exec()</function_name> or
         <function_name>eval()</function_name> to execute
         the compiled code. Once executed, variables in the
         compiled code become variables in the calling code:
         </p>
         
         <pre><code class="language-python">code = "x1 = 10\nprint(x)"
executable_code = compile(code, "<string>", "exec")
exec(executable_code)                     #  10
print(x1)                                 #  10</code></pre>
         
         <p id="the_builtin_functions__complex">
         Create the complex number 1 + i:
         </p>
         
         <pre><code class="language-python">a = complex(1, 1)
print(a)</code></pre>
         
         <p id="the_builtin_functions__delattr">
         Delete an attribute from a class. Note that
         deleting the attribute from the class also deletes
         it from all instances:
         </p>
         
         <pre><code class="language-python">class A:
   value_ = 1

a = A()
delattr(A, "value_")
# print(a.value_)                         #  No such attribute</code></pre>
         
         <p id="the_builtin_functions__dict">
         Create and use a dictionary:
         </p>
         
         <pre><code class="language-python">a = dict()                                #  Or a = {}
a["first"] = 2
print(a)
print(a["first"])</code></pre>
         
         <p id="the_builtin_functions__dir">
         <function_name>dir()</function_name> returns a list
         of names in a scope. Without arguments, it returns
         a list of names in the current local scope. With
         arguments, <function_name>dir(x)</function_name>,
         it returns a list of attributes of
         <constant_name>x</constant_name>:
         </p>
         
         <pre><code class="language-python">print(dir())

class A:
   value_ = 1;

print(dir(A))

class A:
   def __dir__(self):
      return []

print(dir(A()))                           #  []</code></pre>
         
         <p id="the_builtin_functions__divmod">
         <function_name>divmod(a, b)</function_name> takes
         two non-complex numbers as arguments and returns
         two numbers as follows: the quotient and the
         remainder of <constant_name>a / b</constant_name>.
         </p>
         
         <pre><code class="language-python">print(divmod(10,3))                       #  (3, 1)
print(divmod(10.,3.))                     #  (3.0, 1.0)
print(divmod(10.,-3.))                    #  (-4., -2.)
                                          #  because -4*-3+-2=10</code></pre>
         
         <p id="the_builtin_functions__enumerate">
         <function_name>enumerate()</function_name> converts
         an iterator (or an iterable sequence, like an
         array) to an iterator that returns a tuple
         containing the count (starting at 0) and the value
         of the iterator at that index:
         </p>
         
         <pre><code class="language-python">array = ["First", "Second", "Third"]
print(list(enumerate(array)))             #  [ (0, 'First') ... ]

for index, element in enumerate(array):
   print(index, element)                  #  Iteration</code></pre>
         
         <p id="the_builtin_functions__eval">
         <function_name>eval()</function_name> evaluates an
         expression and returns the result of the
         evaluation. It accepts 3 arguments as
         follows:
         <function_name>eval(code, globals, locals).</function_name>
         
         <constant_name>globals</constant_name> is a
         dictionary that specifies what variables and
         functions are available. If
         <constant_name>globals={}</constant_name>, only
         builtin functions are allowed in the evaluated
         expression:
         </p>
         
         <pre><code class="language-python">import math
from math import *

print(eval("sqrt(9)"))                    #  OK - 3.0
# print(eval("sqrt(9)", {}))              #  Error, globals is {},
                                          #  so builtins only.
print(eval("sqrt(9)", {"sqrt":sqrt}))     #  3.0
a = 1
# print(eval("a=2"))                      #  Not allowed
                                          #  Cannot evaluate
                                          #  a statement</code></pre>
         
         <p id="the_builtin_functions__exec">
         <function_name>exec()</function_name> differs from
         <function_name>eval()</function_name> in that:
         <ul>
            <li> <function_name>exec()</function_name> can
                 evaluate multiple lines and statements
            <li> <function_name>exec()</function_name>
                 always returns
                 <constant_name>None</constant_name>
         </ul>
         </p>
         
         <pre><code class="language-python">a = 1
exec("a=2")
print(a)                                  #  2</code></pre>
         
         <p id="the_builtin_functions__filter">
         <function_name>filter(f, i)</function_name>
         constructs an iterator from the elements
         <constant_name>e</constant_name>
         of an iterable
         <constant_name>i</constant_name> for which
         <constant_name>f(e)</constant_name> is true.
         If <constant_name>f</constant_name> is
         <constant_name>None</constant_name>,
         then the truthiness of
         <constant_name>e</constant_name> is tested instead:
         </p>
         
         <pre><code class="language-python">a = [0, 1,2,3,4,5,6,7,8,9,10]
print(list(filter(lambda x : not (x % 2), a)))
                                          #  [0, 2, 4, 6, 8, 10]</code></pre>
         
         <p id="the_builtin_functions__float">
         <function_name>float</function_name> constructs a
         floating point number, parses one from a string, or
         calls <constant_name>x.__float__</constant_name>:
         </p>
         
         <pre><code class="language-python">a = float(1.0)                            #  1
a = float("1.0")                          #  1
a = float("Inf")
print(a)
a = float("INFINITY")                     #  case-insensitive
print(a)
print(float())                            #  0.0

class A:
   def __float__(self):
      return 1.0

a = A()
print(float(a))                           #  1.0

class A:
   def __index__(self):                   # Use __index__, if __float__
      return 1                            # is not present

a = A()
print(float(a))                           #  1.0</code></pre>
         
         <p id="the_builtin_functions__format">
         <function_name>format(x, s)</function_name> returns
         a formatted representation of
         <constant_name>x</constant_name>.
         <constant_name>s</constant_name> is the format
         specification string.
         <constant_name>s</constant_name> accepts many
         options, see
         <a href="https://docs.python.org/3/library/string.html#formatspec">https://docs.python.org/3/library/string.html</a>.
         </p>
         
         <p>
         If <constant_name>x</constant_name> is a class
         object, then <function_name>format()</function_name>
         searches for
         <constant_name>x.__format__</constant_name>:
         </p>
         
         <pre><code class="language-python">a = 1
print(format(x, '05b'))                   #  binary, with 5 figures

class A:
   value_ = 1
   def __format__(self, s):
      if s == "Integer":
         return str(self.value_)
      elif s == "Float":
         return str(float(self.value_))

a = A()
print(format(a, "Integer"))               #  1
print(format(a, "Float"))                 #  1.0</code></pre>
         
         <p id="the_builtin_functions__fronzenset">
         A <function_name>fronzenset</function_name> is an
         immutable set object. It can be constructed from an
         iterable. If the iterable is a dict, only the keys
         of the dictionary are used:
         </p>
         
         <pre><code class="language-python">a = ['a', 'b', 'c']
fs = frozenset(a)
print(fs)                                 #  frozenset({'a', 'b', 'c'})
# fs.add('f')                             #  Not allowed
a = { 'a':1, 'b':2, 'c':3 }
fs = frozenset(a)
print(fs)                                 #  The same</code></pre>
         
         <p id="the_builtin_functions__getattr">
         <function_name>getattr(object, name)
         </function_name> returns the value of the
         attribute of object with name 
         <constant_name>name</constant_name>.
         <constant_name>name</constant_name> must
         be a string.
         
         If the required attribute exists,
         <function_name>getattr(object, name)
         </function_name> is equivalent to
         <constant_name>object.name</constant_name>.
         </p>
         
         <pre><code class="language-python">class A:
   pass

a = A()
a.value_ = 1
print(getattr(a, "value_"))               #  1
print(getattr(a, "not_present_", 2))      #  Default value: 2</code></pre>
         
         <p id="the_builtin_functions__globals">
         <function_name>globals()</function_name> returns a
         dictionary containing the current global symbol
         table:
         </p>
         
         <pre><code class="language-python">a = 1
globals()["a"] = 2
print(a)                                  #  2</code></pre>
         
         <p id="the_builtin_functions__hasattr">
         <function_name>hasattr(object, name)</function_name>
         checks whether
         <constant_name>object</constant_name> contains an
         attribute with name <constant_name>name</constant_name>:
         </p>
         
         <pre><code class="language-python">class A:
   value_ = 1

a = A()
a.value2_ = 2
print(hasattr(a, "value_"))               #  True
print(hasattr(a, "value2_"))              #  True
print(hasattr(a, "value3_"))              #  False</code></pre>
         
         <p id="the_builtin_functions__hash">
         <function_name>hash(x)</function_name> returns the 
         hash of <constant_name>x</constant_name>, if it
         has one.
         If <constant_name>x</constant_name> is an object,
         <function_name>hash(x)</function_name> checks for a
         <constant_name>__hash__</constant_name> method
         which customizes the hash. Hashes are integers,
         truncated to bitwidth of the host machine.
         </p>
         
         <pre><code class="language-python">print(hash(1))
print(hash( (1,2,3) ))                    #  Combined hash of tuple
                                          #  elements</code></pre>
         
         <p>
         If <constant_name>__hash__</constant_name> is
         customized then
         <constant_name>__eq__</constant_name> should also
         be customized:
         </p>
         
         <pre><code class="language-python">class A:
   value_ = 1
   def __eq__(self, other):
      return self.value_ == other.value_
   def __hash__(self):
      return hash(self.value_)

print(hash(A()))
print(hash(A().value_))                   #  The same</code></pre>
         
         <p id="the_builtin_functions__help">
         <function_name>help()</function_name> and 
         <function_name>help(object)</function_name> open a
         builtin interactive help system. If the argument is
         a string, then the help system looks for help pages
         for the specified module, function, class (and so
         on):
         </p>
         
         <pre><code class="language-python">class A:
   pass

# help(A)                                 #  Open interactive help on A</code></pre>
         
         <p id="the_builtin_functions__hex">
         <function_name>hex(o)</function_name> converts an
         integer <constant_name>o</constant_name> to a
         lowercase hex string. The string is prefixed with
         <constant_name>'0x'</constant_name>.
         If <constant_name>o</constant_name> is not an
         integer, then
         <function_name>hex(o)</function_name> searches for
         <constant_name>o.__index__</constant_name>:
         </p>
         
         <pre><code class="language-python">class A:
   def __index__(self):
      return 1

print(hex(A()))                           #  0x1</code></pre>
         
         <p id="the_builtin_functions__id">
         <function_name>id(x)</function_name> gets the
         unique ID of an object
         <constant_name>x</constant_name>.
         Two objects with non-overlapping lifetimes may have
         the same
         <function_name>id()</function_name> value.

         The ID of an object may differ between systems. The
         object to ID may be a class name, a class instance,
         a type, or a dict (among other objects):
         </p>
         
         <pre><code class="language-python">print(id(10))
a = 10
print(id(a))                              #  The same</code></pre>
         
         <p id="the_builtin_functions__input">
         <function_name>input(x)</function_name> gets a line
         from the console. It gets an input from the user
         and then returns it with the trailing newline
         character removed. If
         <constant_name>x</constant_name> is given, it is
         written to stdout without a trailing newline:
         </p>
         
         <pre><code class="language-python">import readline                           #  Allows editing of the
                                          #  input string
# a = input("Enter a string <<< ")
print(a)</code></pre>
         
         <p id="the_builtin_functions__int">
         <function_name>int(x)</function_name> instantiates
         an integer, <constant_name>x</constant_name>, or
         parses a string as an integer.
         If a second argument is given -
         <function_name>int(x, b)</function_name> - then
         <constant_name>x</constant_name>
         should be a string (or a bytearray) expressed in
         base <constant_name>b</constant_name>. The allowed
         bases are 0 and 2-36.
         
         If <constant_name>x</constant_name> is a floating
         point number,
         <function_name>int(x)</function_name> truncates
         toward zero.
         If <constant_name>x</constant_name> is an object,
         <function_name>int(x)</function_name> searches
         for <constant_name>__int__</constant_name>, then
         for <constant_name>__index__</constant_name> (if
         <constant_name>__int__</constant_name> is not
         present), then for
         <constant_name>__trunc__</constant_name>.
         </p>
         
         <pre><code class="language-python">print(int())                              #  0
print(int(2.7))                           #  2
print(int(-2.7))                          #  -2

class A:
   def __int__(self):
      return 3
a = A()
print(int(a))                             #  3

print(int("0b1", 2))                      #  1
print(int('9', 36))                       #  9
print(int('a', 36))                       #  10
print(int('z', 36))                       #  35</code></pre>
         
         <p id="the_builtin_functions__isinstance">
         <function_name>isinstance(o, c)</function_name>
         checks whether <constant_name>o</constant_name>
         is an instance (or is a subclass) of a class type,
         <constant_name>c</constant_name>.
         </p>
         
         <p>
         <constant_name>c</constant_name> can be a tuple of
         typenames, in which case 
         <function_name>isinstance</function_name> returns
         <constant_name>True</constant_name> if
         <constant_name>o</constant_name> is an
         instance of at least one of the tuple elements.
         </p>
         
         <pre><code class="language-python">a = 3

print(isinstance(a, list))                #  False
print(isinstance(a, (list, int)))         #  True</code></pre>
         
         <p id="the_builtin_functions__issubclass">
         <function_name>issubclass(c1, c2)</function_name>
         checks whether <constant_name>c1</constant_name> is
         a subclass of class type
         <constant_name>c2</constant_name>. A class is
         considered to be a subclass of itself.
         
         <constant_name>c2</constant_name> can be a tuple of
         typenames, in which case
         <function_name>issubclass</function_name>
         returns <constant_name>True</constant_name> if
         <constant_name>c1</constant_name>
         is a subclass of at least one of the tuple elements.
         </p>
         
         <pre><code class="language-python">a = 3

print(issubclass(type(a), list))          #  False
print(issubclass(type(a), (list, int)))   #  True

class A:
   pass
class B(A):
   pass

print(issubclass(B, A))                   #  True</code></pre>
         
         <p id="the_builtin_functions__iter">
         <function_name>iter(x)</function_name> returns an
         iterator view of <constant_name>x</constant_name>.
         If <constant_name>x</constant_name> is an object,
         then <constant_name>x</constant_name>
         should implement
         <constant_name>__iter__</constant_name> and
         <constant_name>__next__</constant_name>.
         </p>
         
         <p>
         <function_name>iter(x, s)</function_name> returns
         an iterator view of
         <constant_name>x</constant_name>, with sentinel
         <constant_name>s</constant_name>. Iteration
         is stopped when <constant_name>x()</constant_name>
         is <constant_name>s</constant_name>. In this case,
         <constant_name>x</constant_name>
         should be callable (Ie. it should implement
         <constant_name>__call__</constant_name>):
         </p>
         
         <pre><code class="language-python">class A:
   def __init__(self):
      self.value_ = 0
   def __iter__(self):
      return self
   def __next__(self):
      if(self.value_ > 6):
         raise StopIteration
      value = self.value_
      self.value_ += 2
      return self.value_
   __call__ = __next__

a = A()
print(list(iter(a)))                      #  [2, 4, 6, 8]
print(list(iter(A(), 6)))                 #  [2, 4]</code></pre>
         
         <p id="the_builtin_functions__len">
         <function_name>len(x)</function_name> returns the
         number of items comprising
         <constant_name>x</constant_name>.
         <constant_name>x</constant_name> can be a sequence
         (including strings) or a collection.
         
         If <constant_name>x</constant_name> is a custom
         object, <function_name>len(x)</function_name> calls
         <constant_name>x.__len__</constant_name>.
         </p>
         
         <pre><code class="language-python">class A:
   def __len__(self):
      return 2

a = A()
print(len(a))                             #  2</code></pre>
         
         
         
         
         
         <!-- TODO: remove -->
         
         <p id="the_builtin_functions__list">
         <function_name>list()</function_name> and
         <function_name>list(iterable)</function_name>
         create a mutable sequence type. Slicing and array
         access are both supported:
         </p>
         
         <pre><code class="language-python">a = list()
a.append(1)
print(a)                                  #  [1]
a = list({"1":1, "2":2})
print(a)                                  #  Keys only: ['1', '2']</code></pre>
         
         <p id="the_builtin_functions__locals">
         <function_name>locals()</function_name> returns a
         dictionary containing the local symbol table:
         </p>
         
         <pre><code class="language-python">def f(x):
   print(locals())                        #  { 'x':1 }
f(1)</code></pre>
         
         <p id="the_builtin_functions__map">
         <function_name>map(f, i)</function_name> applies a
         function <constant_name>f</constant_name> to every
         element of an iterable,
         <constant_name>i</constant_name>, returning a new
         iterator containing the mapped results. If multiple
         iterables <constant_name>i1</constant_name>,
         <constant_name>i2</constant_name> are provided -
         <function_name>map(f, i1, i2...)</function_name> -
         then
         <constant_name>f</constant_name> must accept that
         many arguments:
         </p>
         
         <pre><code class="language-python">print(list(map(lambda x : 2*x, [1,2,3]))) #  [2, 4, 6]
a = map(lambda n1,n2:(n1 + n2), [1,2,3], [4,5,6])
print(list(a))                            #  [5, 7, 9]</code></pre>
         
         <p id="the_builtin_functions__max">
         <function_name>max(i)</function_name> returns the
         largest element in an iterable
         <constant_name>i</constant_name>.
         <function_name>max(x1, x2...)</function_name>
         returns the largest element among
         objects <constant_name>x1</constant_name>,
         <constant_name>x2</constant_name>... . A default
         return value can also be specified for iterables.
         </p>
         
         <pre><code class="language-python">print(max([1,2,3]))                       #  3
print(max(1, 2, 3))                       #  3
print(max([], default=3))                 #  3
a = {1:1,2:4}
print(max(a,key=lambda k:a[k]))           #  The key having the
                                          #  largest value, 2.</code></pre>
         
         <p id="the_builtin_functions__min">
         <function_name>min(i)</function_name> returns the
         lowest element in an iterable
         <constant_name>i</constant_name>.
         <function_name>min(x1, x2...)</function_name>
         returns the lowest element among
         objects <constant_name>x1</constant_name>,
         <constant_name>x2</constant_name>... . A default
         return value can also be specified for iterables.
         </p>
         
         <pre><code class="language-python">print(min([1,2,3]))                       #  1
print(min(1, 2, 3))                       #  1
print(min([], default=3))                 #  3
a = {1:1,2:4}
print(min(a,key=lambda k:a[k]))           #  The key having the
                                          #  lowest value, 1.</code></pre>
         
         <p id="the_builtin_functions__next">
         <function_name>next(o)</function_name> gets the
         next item from an iterator
         <constant_name>o</constant_name>. It
         calls <constant_name>o.__next__</constant_name>,
         which raises a
         <constant_name>StopIteration</constant_name>
         exception when the iterator is exhausted. If a
         second argument is given,
         <function_name>next(o, d)</function_name>, then
         <constant_name>d</constant_name> is returned when
         the iterator is exhausted:
         </p>
         
         <pre><code class="language-python">a = iter([1])
print(next(a))                            #  1
a = iter([1])
next(a)
print(next(a, 2))                         #  2</code></pre>
         
         <p id="the_builtin_functions__object">
         <function_name>object()</function_name> creates a
         basic object. <i>object</i> is a base class for all
         other classes. It contains methods that are common
         to all python classes:
         </p>
         
         <pre><code class="language-python">a = object()
print(dir(a))</code></pre>
         
         <p id="the_builtin_functions__oct">
         <function_name>oct()</function_name> converts an
         integer to its octal representation. The string
         representation is prefixed with
         <constant_name>'0o'</constant_name>. If
         <constant_name>x</constant_name> is an object (not
         an int) then it must define
         <constant_name>__index__</constant_name>:
         </p>
         
         <pre><code class="language-python">class A:
   def __index__(self):
      return 1
a = A()
print(oct(a))                             #  0o1
print(oct(0b1))                           #  0o1</code></pre>
         
         <p id="the_builtin_functions__open">
         <function_name>open(f)</function_name> opens a file
         <constant_name>f</constant_name> for IO operations
         (which may include writing). There are many
         additional arguments (see <a href="https://docs.python.org/3/library/functions.html#open">https://docs.python.org/3/library/functions.html#open</a>)
         for buffering, encoding, how encoding and decoding
         errors should be handled, and how to parse newline
         characters in the stream.
         </p>
         
         <pre><code class="language-python">with open("./2.txt", 'r') as stream:
   line = stream.readline()
   print(line.strip())</code></pre>
         
         <p id="the_builtin_functions__ord">
         <function_name>ord(x)</function_name> returns the
         string representation of one unicode character
         <constant_name>x</constant_name>. This is the
         inverse function of
         <function_name>chr()</function_name>:
         </p>
         
         <pre><code class="language-python">print(chr(ord('')));                     #  </code></pre>
         
         <p id="the_builtin_functions__pow">
         <function_name>pow(x, y)</function_name> returns
         <constant_name>x</constant_name> raised to the
         power <constant_name>y</constant_name>. If a
         third argument is given,
         <function_name>pow(x, y, b)</function_name>, then
         the returned value is
         <constant_name>x**y mod b</constant_name>. If
         <constant_name>x</constant_name> is negative and
         <constant_name>y</constant_name> is not an integer,
         a complex value is returned.
         If <constant_name>y</constant_name> is negative,
         <constant_name>b</constant_name> is given and all
         arguments are integers, then
         <constant_name>x</constant_name> must be relatively
         prime to <constant_name>mod</constant_name> and
         <function_name>pow(x, y, b) = pow(x**-1, -y, b)</function_name> 
         where <constant_name>x**-1</constant_name> is
         the inverse of <constant_name>x</constant_name>
         mod <constant_name>b</constant_name>.
         </p>
         
         <pre><code class="language-python">print(pow(2, 3))                          #  8</code></pre>
         
         <p id="the_builtin_functions__print">
         <function_name>print(*x)</function_name> prints the
         objects <constant_name>x</constant_name> to a text
         stream. By default the stream is ::std::cout. Use
         <function_name>print(*x, sep, end)</function_name>
         to specify the separator and
         terminator characters, respectively.
         
         To print to a custom object
         <constant_name>o</constant_name>, call print as
         follows
         <function_name>print(*x, file=o)</function_name>,
         and implement
         <constant_name>o.write(self, string)</constant_name>:
         </p>
         
         <pre><code class="language-python">class A:
   def write(self, string):
      print(string, end='')

a = A()
print(1, file=a)                          #  1</code></pre>
         
         <p id="the_builtin_functions__property">
         <function_name>property(g, s, d, doc)</function_name>
         creates a class property attribute out of a getter
         <constant_name>g</constant_name>,
         a setter <constant_name>s</constant_name>, and a
         deleter <constant_name>d</constant_name>.
         <constant_name>doc</constant_name> is a
         documentation string to assign to the property.
         
         Using <function_name>property</function_name> you
         can control the behaviour of expressions like
         <constant_name>x.name</constant_name> and
         <constant_name>del x.name</constant_name>, where
         <constant_name>x</constant_name> is
         the name of a property. You must specify the
         getter, the setter, and the deleter methods:
         </p>
         
         <pre><code class="language-python">class A:
   def __init__(self, value):
      self._value = value
   def get_value(self):
      return self._value
   def set_value(self, value):
      self._value = value
   def del_value(self):
      del self._value
   value = property(get_value, set_value, del_value, "Value")

a = A(0)
print(a.value)                            #  a.get_value()
a.value = 1                               #  a.set_value(1)
print(a.value)                            #  1
del a.value                               #  a.del_value()

#
# Alternatively, using the @property decorator:
#

class A:
   def __init__(self, value):
      self._value = value
   @property
   def value(self):
      return self._value
   @value.setter
   def value(self, value):
      self._value = value
   @value.deleter
   def value(self):
      del self._value

a = A(0)
print(a.value)                            #  a.get_value()
a.value = 1                               #  a.set_value(1)
print(a.value)                            #  1
del a.value                               #  a.del_value()</code></pre>
         
         <p id="the_builtin_functions__range">
         <function_name>range(start, stop, step)</function_name>
         constructs an immutable
         sequence type consisting of the elements from
         <constant_name>start</constant_name> (inclusive) to
         <constant_name>stop</constant_name> (exclusive) in
         steps of size <constant_name>step</constant_name>.
         <constant_name>Step</constant_name> must be an
         integer.
         </p>
         
         <pre><code class="language-python">class A:
   def __repr__(self):
      return '2'

a = A()
print(repr(a))                            #   '2'</code></pre>
         
         <p id="the_builtin_functions__repr">
         <function_name>repr(x)</function_name> returns a
         string containing a printable representation of an
         object <constant_name>x</constant_name>. In many
         cases the string representation will yield an
         object with the same value when passed to
         <function_name>eval()</function_name>.
         If <constant_name>x</constant_name> is a class,
         <function_name>repr(x)</function_name> calls
         <constant_name>x.__repr__</constant_name>:
         </p>
         
         <pre><code class="language-python">class A:
   def __repr__(self):
      return '2'

a = A()
print(repr(a))                            #   '2'</code></pre>
         
         <p id="the_builtin_functions__reversed">
         <function_name>reversed(s)</function_name>
         constructs a reverse iterator from a
         sequence <constant_name>s</constant_name>.
         <constant_name>s</constant_name> must provide
         <constant_name>s.__reversed__</constant_name>
         (eg. arrays, ranges, tuples) or it must
         implement the sequence protocol:
         <constant_name>s.__len__</constant_name> must
         exist, as well as
         <constant_name>s.__getitem__</constant_name>:
         </p>
         
         <pre><code class="language-python">print(list(reversed([1,2,3])))            #  [3,2,1]
print(list(reversed(range(1,4))))         #  The same
print(list(reversed((1,2,3))))            #  The same

class A:
   arr_ = [1,2,3]
   def __len__(self):
      return len(self.arr_)
   def __getitem__(self, index):
      return self.arr_[index]

a = A()
print(list(reversed(a)))                  #  [3,2,1]</code></pre>
         
         <p id="the_builtin_functions__round">
         <function_name>round(x, n)</function_name> rounds
         <constant_name>x</constant_name> to
         <constant_name>n</constant_name> digits after the
         decimal point. If
         <constant_name>n</constant_name> is not given (or
         is <constant_name>None</constant_name>), it rounds
         to the nearest integer.
         If <constant_name>x</constant_name> is half way
         between the nearest rounded values, it is rounded
         toward the even choice. If
         <constant_name>x</constant_name> is an object,
         <function_name>round()</function_name> delegates
         to <constant_name>x.__round__</constant_name>:
         </p>
         
         <pre><code class="language-python">class A:
   number_ = 1.5
   def __round__(self):
      return round(self.number_)

a = A()
print(round(a))                           #  2</code></pre>
         
         <p id="the_builtin_functions__set">
         <function_name>set()</function_name> constructs a
         mutable version of a
         <function_name>frozenset</function_name>.
         If an iterable <constant_name>x</constant_name> is
         given, <function_name>set(x)</function_name> is
         populated with the items in
         <constant_name>x</constant_name>:
         </p>
         
         <pre><code class="language-python">a = set([1,2])
print(a)                                  #  {1,2,3}
b = set([1,2,3])
print(a < b)                              #  True: a is contained
                                          #  in b</code></pre>
         
         <p id="the_builtin_functions__setattr">
         <function_name>setattr(object, name, value)</function_name>
         is equivalent to
         <constant_name>object.name = value</constant_name>.
         Note that object can be a class name or an
         instance:
         </p>
         
         <pre><code class="language-python">class A:
   pass
setattr(A, "value_", 1);
a = A()
print(a.value_)</code></pre>
         
         <p id="the_builtin_functions__slice">
         <function_name>slice(stop)</function_name> and
         <function_name>slice(stop, start, step)</function_name>
         return slice objects that can be used to slice any
         sequence. <constant_name>stop</constant_name>,
         <constant_name>start</constant_name>,
         <constant_name>step</constant_name> must all be
         integers. Note that all three arguments can be
         negative, in which case slicing starts at the end
         of the string and works backwards.

         Slice objects contain attributes named
         <constant_name>stop</constant_name>,
         <constant_name>start</constant_name>
         and <constant_name>step</constant_name> with the
         same value as the arguments.
         </p>
         
         <pre><code class="language-python">indices = slice(2)
a = [1,2,3]
print(a[indices])                         #  [1,2]
print(indices.stop)
indices = slice(-1,-3,-1)
print(a[indices])                         #  [3,2]

#
# Alternatively, use extended indexing syntax:
#

print(a[-1:-3:-1])                        #  The same</code></pre>
         
         <p id="the_builtin_functions__sorted">
         <function_name>sorted(x, key=None, reverse=False)</function_name>
         constructs a new list containing the sorted values
         of an iterable <constant_name>x</constant_name>.
         If <constant_name>key</constant_name> is specified
         then it should be a univariate function that
         extracts a comparison key from each
         element in <constant_name>x</constant_name>. The
         sort is stable.
         </p>
         
         <pre><code class="language-python">a = [1,3,2]
print(sorted(a))                          #  [1,2,3]
a = [(1,2),(2,1)]
print(sorted(a,key=lambda x : x[1]))      #  Sort by the second
                                          #  tuple element</code></pre>
         
         <p id="the_builtin_functions__staticmethod">
         <function_name>@staticmethod</function_name>
         transforms a class method into a static method.
         Static methods have no implicit 'self' argument.
         (nor do they have implicit class name arguments,
         like <function_name>@classmethod</function_name>).
         </p>
         
         <pre><code class="language-python">class A:
   @staticmethod
   def f(x):
      return (x + 1)

a = A()
print(a.f(1))                             #  2
print(A.f(1))                             #  2</code></pre>
         
         <p id="the_builtin_functions__str">
         <function_name>str(x)</function_name> returns a
         string representation of
         <constant_name>x</constant_name>. If
         <constant_name>x</constant_name>
         is an integer, float or complex then
         <function_name>str(x)</function_name> is a
         string that parses to the same value.
         </p>
         
         <pre><code class="language-python">print(complex(str(complex(1,1))))

#
# If x is a bytes object, or a bytearray object, then
# str(x, encoding='utf-8', errors='strict') accepts two
# additional arguments that specify the byte encoding and
# what to do if an invalid encoded character is detected:
#

a = [112, 121, 116, 104, 111, 110]        # "python"
a = bytes(a)
print(str(a, encoding='utf-8'))           # "python"</code></pre>
         
         <p id="the_builtin_functions__sum">
         <function_name>sum(x, start=0)</function_name> sums
         the items of an iterable and returns the total
         value. If <constant_name>start</constant_name> is
         given, it is added to the total:
         </p>
         
         <pre><code class="language-python">print(sum([1,2,3]))
print(sum([1,2,3],start=1))               #  2+3=5

#
# To sum floating-point iterables with extended precision,
# use math.fsum instead:
#

import math
print(math.fsum([0.5, 1.5]))              #  2.0</code></pre>
         
         <p id="the_builtin_functions__super">
         <function_name>super()</function_name> has two main
         use cases. Firstly, it removes the need to name a
         base class explicitly (for example during ctor
         evaluation):
         </p>
         
         <pre><code class="language-python">class A:
   def __init__(self, x):
      print("A")
      self.x = x
class B(A):
   def __init__(self, x):
      print("B")
         #
         # Returns a proxy object that delegates to the
         # methods in A:
         #
      super().__init__(x)
      # Alternatively: A.__init__(self, x)

b = B(1)                                  #  B A</code></pre>
         
         <p>
         Secondly, it chains multiply-inherited classes
         together according to their
         <constant_name>__mro__</constant_name> (method
         resolution order). The
         <constant_name>__mro__</constant_name> that is
         evaluated belongs to the instantiated class, not to
         the base class (which, on its own, will may have a
         different <constant_name>__mro__</constant_name>).
         </p>

         <p>
         <function_name>super()</function_name> with no
         arguments only works inside of a class definition.
         The compiler fills in the necessary missing
         arguments. This means that
         <function_name>super(type, object_or_type)</function_name>
         can be used outside of a class definition. In this
         form, if
         <constant_name>object_or_type</constant_name> is an
         instance, then
         <function_name>super()</function_name> generates
         a proxy for the next object in the
         <constant_name>__mro__</constant_name> of
         <constant_name>object_or_type</constant_name> after
         <constant_name>type</constant_name>.
         </p>
         
         <p>
         You cannot use indexed expressions like
         <function_name>super()[name]</function_name> with
         <function_name>super()</function_name>: only dotted
         attribute lookups.
         </p>
         
         <pre><code class="language-python">class A:
   def __init__(self, x):
      print("A")
      self.x = x
class B(A):
   def __init__(self, x):
      print("B")
      super().__init__(x)                 # Same as super(B, self)
class C(A):
   def __init__(self, x):
      print("C")
      super().__init__(x)                 # Same as super(C, self)
   def f(self):
      print("f")
   @staticmethod
   def g():
      print("g")
class D(C, B):
   def __init__(self, x):
      print("D")
      super().__init__(x)

d = D(1)                                  #  D C B A

super(D, d).f()                           #  "f"
super(D, D).g()                           #  Allowed - "g"</code></pre>
         
         <p id="the_builtin_functions__tuple">
         <function_name>tuple()</function_name> and
         <function_name>tuple(iterable)</function_name> are
         immutable sequence types. Tuples support indexing
         and slicing.
         </p>
         
         <pre><code class="language-python">a = tuple([1,2,3])
print(a[1:3])                             #  (2,3)

a = (1,2) + (3,4)
print(a)                                  #  (1,2,3,4)

a = (1,2)*3
print(a)                                  #  (1,2,1,2,1,2)

print((1,2,1).count(1))                   #  2</code></pre>
         
         <p id="the_builtin_functions__type">
         <function_name>type(x)</function_name> returns the
         type of <constant_name>x</constant_name>, which is
         usually the same as
         <constant_name>x.__class__</constant_name>.
         </p>
         
         <p>
         <function_name>type(name, bases, dict)</function_name>
         creates a new type, even it has not been previously
         declared as a class. In this case
         <constant_name>name</constant_name> becomes the
         <constant_name>__name__</constant_name> attribute,
         <constant_name>bases</constant_name> becomes the
         <constant_name>__bases__</constant_name> attribute,
         and <constant_name>dict</constant_name>
         contains definitions for the class body and becomes
         the <constant_name>__dict__</constant_name>
         attribute. This form is essentially a dynamic form
         of the <constant_name>class</constant_name>
         statement. If <constant_name>bases</constant_name>
         is empty then
         <constant_name>'object'</constant_name> is
         automatically added to it.
         </p>
         
         <pre><code class="language-python">a = 1
print(type(a))                            #  int

del B
del A
a = type('A', (), {'value_':1})
print(a.value_)                           #  1</code></pre>
         
         <p id="the_builtin_functions__vars">
         <function_name>vars(x)</function_name> returns the
         <constant_name>__dict__</constant_name> attribute
         for any object (or module) that has it, otherwise
         it raises a
         <constant_name>TypeError</constant_name>.
         <function_name>vars()</function_name>
         (no arguments) returns methods in the local scope.
         </p>
         
         <pre><code class="language-python">print(vars(tuple))
print(tuple.__dict__)                     #  The same</code></pre>
         
         <p id="the_builtin_functions__zip">
         <function_name>zip(*iterables, strict=False)</function_name>
         iterates over several
         <constant_name>iterables</constant_name> in
         parallel. It produces tuples containing one item
         per iterable. The zip iterator is as long as the
         shortest iterable, unless
         <constant_name>strict=True</constant_name>, in
         which case a
         <constant_name>ValueError</constant_name> is raised
         if the iterables do not have the same length.
         </p>
         
         <pre><code class="language-python">print(list(zip([1,2], (3,4,5))))          #  [(1, 3), (2, 4)]
a = [1,2]
b = [3,4]
c = list(zip(a, b))
a, b = zip(*c)                            #  a = (1,2) b = (3,4)
print(a,b)</code></pre>
         
         <h2 id="operator_overloading">
            Operator Overloading
         </h2>
         
         <p>
         The operators <constant_name>+</constant_name>,
         <constant_name>-</constant_name>,
         <constant_name>%</constant_name> (modulo),
         <constant_name>*</constant_name>,
         <constant_name>**</constant_name> (power),
         <constant_name>/</constant_name>,
         <constant_name>//</constant_name> (floor-division),
         <constant_name>&lt;&lt;</constant_name>,
         <constant_name>&gt;&gt;</constant_name>,
         <constant_name>&</constant_name>,
         <constant_name>|</constant_name>,
         <constant_name>^</constant_name> and
         <constant_name>~</constant_name> (not) can all be
         customized ("overloaded") for python classes.
         For example: <constant_name>+</constant_name> adds
         two integers, whereas it concatenates two lists. 
         In addition, the boolean comparison operators
         <constant_name>&lt;</constant_name>,
         <constant_name>&lt;=</constant_name>,
         <constant_name>&gt;</constant_name>,
         <constant_name>&gt;=</constant_name>,
         <constant_name>==</constant_name> and
         <constant_name>!=</constant_name>
         can also be overloaded.
         </p>
         
         <p>
         Internally, the expression
         <constant_name>a + b</constant_name> calls
         <constant_name>a.__add__(b)</constant_name>.
         Likewise, all of the other arithmetical and
         comparison operators have equivalent functional
         forms using double-underscore functions.
         These functions can be customized for class types.
         </p>
         
         <p>
         This class demonstrates how to overload all of the
         arithmetical operators and all of the boolean
         comparison operators:
         </p>
         
         <pre><code class="language-python">#
# Operator overloading:
#

class A:
   def __init__(self, value):
      self.value_ = value
   
   #
   # Overloaded arithmetical operators:
   #
   
   #
   # a + b:
   #
   
   def __add__(self, other):
      print("+")
      return A(self.value_ + other.value_)
   
   #
   # a - b
   #
   
   def __sub__(self, other):
      print("-")
      return A(self.value_ - other.value_)
   
   #
   # a % b:
   #
   
   def __mod__(self, other):
      print("%")
      return A(self.value % other.value_)
   
   #
   # a * b
   #
   
   def __mul__(self, other):
      print("*")
      return A(self.value_ * other.value_)
   
   #
   # a ** b:
   #
   
   def __pow__(self, other):
      print("**")
      return A(self.value_ ** other.value_)
   
   #
   # a / b
   #
   
   def __truediv__(self, other):
      print("/")
      return A(self.value_ / other.value_)
   
   #
   # a // b:
   #
   
   def __floordiv__(self, other):
      print("//")
      return A(self.value_ // other.value_)
   
   #
   # a << b:
   #
   
   def __lshift__(self, other):
      print("<<")
      return A(self.value << other.value_)
   
   #
   # a >> b
   #
   
   def __rshift__(self, other):
      print(">>")
      return A(self.value >> other.value_)
   
   #
   # a & b
   #
   
   def __and__(self, other):
      print("&")
      return A(self.value & other.value_)
   
   #
   # a | b
   #
   
   def __or__(self, other):
      print("|")
      return A(self.value | other.value_)
   
   #
   # a ^ b
   #
   
   def __xor__(self, other):
      print("^")
      return A(self.value ^ other.value_)
   
   #
   # ~a
   #
   
   def __invert__(self):
      print("~")
      return A(~self.value)
   
   #
   # Overloaded comparison operators:
   #
   
   #
   # a < b
   #
   
   def __lt__(self, other):
      print("<")
      return (self.value_ < other.value_)
   
   #
   # a > b
   #
   
   def __gt__(self, other):
      print(">")
      return (self.value_ > other.value_)
   
   #
   # a == b
   #
   
   def __eq__(self, other):
      print("==")
      return (self.value_ == other.value_)
   
   # 
   # a != b
   #
   
   def __ne__(self, other):
      print("!=")
      return (self.value_ < other.value_)
   
   #
   # a <= b
   #
   
   def __le__(self, other):
      print("<=")
      return (self.value_ <= other.value_)
   
   #
   # a >= b
   #
   
   def __ge__(self, other):
      print(">=")
      return (self.value_ >= other.value_)
   
   def __repr__(self):
      return str(self.value_)

a = A(1)
b = A(2)

print(a + b)                              #  + 3
print(b ** a)                             #  ** 2
print(a <= b)                             #  <= True</code></pre>
         
         
         <h2 id="closures">
            Closures
         </h2>
         
         <p>
         Nested functions can access variables in the
         enclosing function scope:
         </p>
         
         <pre><code class="language-python">def f(message):
   def g():
      print(message)
   g()

f("Hello World!")</code></pre>
         
         <p>
         Assigning to variables in the enclosing scope will
         produce a copy:
         </p>
         
         <pre><code class="language-python">def f(number):
   def g():
      number = 2
   g()
   print(number)

f(1)                                         #  1, not 2</code></pre>
         
         <p>
         Unless the inner function variable is declared
         nonlocal:
         </p>
         
         <pre><code class="language-python">def f(number):
   def g():
      nonlocal number
      number = 2
   g()
   print(number)

f(1)                                         #  2</code></pre>
         
         <p>
         Inner functions can still access variables in the
         parent function scope if the inner function is
         returned. This is called a <i>closure</i>.
         </p>
         
         <pre><code class="language-python">def f(number):
   def g():
      print(number)
   return g

a = f(1)
a()                                          #  1</code></pre>
         
         <p>
         To print a list of variables captured by the
         closure:
         </p>
         
         <pre><code class="language-python">print(a.__closure__)</code></pre>
         
         <p>
         If a function returns multiple closures, the
         variables captured by the closure can be shared:
         </p>
         
         <pre><code class="language-python">def f(number):
   def g():
      nonlocal number
      number += 1
      print(number)
   def h():
      nonlocal number
      number += 2
      print(number)
   return (g, h)

a,b = f(1)
a()                                          #  2
b()                                          #  4, not 3</code></pre>
         
         <h2 id="generators">
            Generators
         </h2>
         
         <p>
         To create a generator, use the
         <constant_name>'yield'</constant_name> keyword as
         follows. Functions that
         <constant_name>yield</constant_name> values can be
         called like iterators.
         </p>
         
         <p>
         The generator will be evaluated up until
         the first <constant_name>yield</constant_name>
         statement, then it will suspend until it is called
         again.
         </p>
         
         <p>
         Generators can be more memory efficient than class
         iterators. Generators only evaluate the items they
         return when they are called.
         </p>
         
         <pre><code class="language-python">def generator(n):
   counter = 0
   while(counter < n):
      yield counter
      counter += 1

print(generator(2))                          #  Not 0

#
# A for loop can be used to extract values from generators:
#

for value in generator(4):
   print(value)                              #  0 1 2 3</code></pre>
         
         <p>
         Alternatively:
         </p>
         
         <pre><code class="language-python">g = generator(2)
print(next(g))                               #  0
print(next(g))                               #  1</code></pre>
         
         <p>
         The elements returned by generators (and by
         iterators) can be modified using the following
         syntax:
         </p>
         <p>
         <div style='margin-left:4em' >
            (<constant_name>expression</constant_name> for
            <constant_name>item</constant_name> in
            <constant_name>generator</constant_name>):
         </div>
         </p>
         
         <pre><code class="language-python">squares = (i * i for i in generator(3))
for i in squares:
   print(i)                                  #  0 1 4</code></pre>
         
         <p>
         Generators can also be combined into 'pipelines' as
         follows:
         </p>
         
         <pre><code class="language-python">def generator(n):
   counter = 0
   while(counter < n):
      yield counter
      counter += 1
def square(gen):
   for item in gen:
      yield item * item

print(max(square(generator(4))))             #  9</code></pre>
         
         
         <h2 id="coroutines">
            Coroutines
         </h2>
         
         <p>
         In a sense, coroutines are the opposite of
         generators. Generators produce data whereas
         coroutines consume data.
         
         When a coroutine is called for the first time,
         nothing happens. The coroutine only advances to the
         field <constant_name>yield</constant_name>
         statement when
         <constant_name>coroutine.__next__</constant_name>
         or <function_name>next(coroutine)</function_name>
         is called. At this point execution
         is suspended until
         <function_name>coroutine.send(data)</function_name>
         is called.
         <constant_name>data</constant_name> is inserted at
         the position of the
         <constant_name>(yield)</constant_name>
         keyword.
         </p>
         
         <pre><code class="language-python">def echo(modifier):
   while True:
      message = (yield)
      modified_message = modifier(message)
      print(modified_message)

coroutine = echo(lambda x : "log: " + x)

#
# Advance to the first 'yield' expression:
#

next(coroutine)

coroutine.send("Hello")                   #  log: Hello
coroutine.send("World!")                  #  log: World!</code></pre>
         
         <p>
         Coroutines can run indefinitely: they can accept an
         indefinite number of
         <function_name>send()</function_name> operations.
         A coroutine can be closed by calling
         <function_name>coroutine.close()</function_name>. 
         This raises a
         <constant_name>GeneratorExit</constant_name>
         exception, which the coroutine can capture:
         </p>
         
         <pre><code class="language-python">def echo(modifier):
   try:
      while True:
         message = (yield)
         modified_message = modifier(message)
         print(modified_message)
   except GeneratorExit:
      print("closing coroutine")

coroutine = echo(lambda x : "log: " + x)

next(coroutine)

coroutine.send("Hello")                   #  log: Hello
coroutine.send("World!")                  #  log: World!
coroutine.close()                         #  "closing coroutine"</code></pre>
         
         <p>
         Coroutines can be chained together into pipelines:
         </p>
         
         <pre><code class="language-python">def producer(message, next_coroutine):
   next(next_coroutine)
   lines = message.split("\n")
   for line in lines:
      next_coroutine.send(line)
   next_coroutine.close()

def add_prefix(next_coroutine):
   next(next_coroutine)
   try:
      while True:
         message = (yield)
         next_coroutine.send("log: " + message)
   except GeneratorExit:
      pass

def state_message_len():
   try:
      while True:
         message = (yield)
         print(message + " (" + str(len(message)) + ")")
   except GeneratorExit:
      pass

producer("Hello\nWorld!", add_prefix(state_message_len()))</code></pre>
         
         
         <h2 id="decorators">
            Function Decorators
         </h2>
         
         <p>
         Decorators are functions that modify other
         functions. The decorator accepts one argument - the
         function to modify - and returns another function -
         the modified function. This is typically done using
         a closure:
         </p>
         
         <pre><code class="language-python">def prefix_log_message(delegate):
   def function(message):
      print("log: ")
      delegate(message)
   return function

@prefix_log_message
def log(message):
   print(message)

log("Hello World!")</code></pre>
         
         <p>
         Decorators can be chained together. The most inner
         decorator (in this example,
         <constant_name>'@square'</constant_name>) is
         evaluated first.
         </p>
         
         <pre><code class="language-python">def add_one(delegate):
   def function(n):
      return (delegate(n) + 1)
   return function

def square(delegate):
   def function(n):
      value = delegate(n)
      return (value * value)
   return function

@add_one
@square
def identity(n):
   return n

print(identity(1))                        #  1**2 + 1 = 2
print(identity(2))                        #  2**2 + 1 = 5</code></pre>
         
         <h2 id="properties">
            Properties
         </h2>
         
         <p>
         Property attributes allow you to customize the
         behaviour of attribute get/set expressions like 
         <constant_name>a.value = (object)</constant_name>:
         </p>
         
         <pre><code class="language-python">class A:
   def __init__(self):
      self.value = 1

a = A()
a.value = 2                # Internally equivalent to
                           # a.__dict__['value']</code></pre>
         
         <p>
         Now make <constant_name>value</constant_name>
         private and implement a getter and a setter for it:
         </p>
         
         <pre><code class="language-python">class A:
   def __init__(self):
      self._value = 1
   def get_value(self):
      return self._value
   def set_value(self, value):
      self._value = value</code></pre>
         
         <p>
         The above is not backward-compatible with the syntax
         <constant_name>a.value = (number)</constant_name>.
         To make it compatible, use a property attribute as
         follows:
         </p>
         
         <pre><code class="language-python">#
# Making _value a property attribute:
#

class A:
   def __init__(self):
      self._value = 1
   def get_value(self):
      return self._value
   def set_value(self, value):
      self._value = value
   value = property(get_value, set_value)

a = A()
a.value = 2
print(a._value)</code></pre>
         
         <p>
         Using the <function_name>@property</function_name>
         decorator the same code can be accomplished as
         follows. Note that the setter function,
         <function_name>value(self,value)</function_name>,
         below, cannot be named
         <function_name>set_value</function_name>:
         </p>
         
         <pre><code class="language-python">class A:
   def __init__(self):
      self._value = 1
   @property
   def value(self):
      return self._value
   @value.getter
   def value(self):
      return self._value
   @value.setter
   def value(self, value):
      self._value = value

a = A()
a.value = 2
print(a.value)</code></pre>
         
         
         <h2 id="serialization">
            Serialization / Marshalling / Pickling
         </h2>
         
         <p>
         Serialization is sometimes called marshalling or
         (in python) 'pickling'.
         Deserialization is sometimes called unmarshalling
         or (in python) 'unpickling'.
         </p>
         
         <p>
         There is more than one type of serialization in the
         python standard library. Examples include
         <constant_name>json</constant_name>
         (which converts objects to textural JSON and back),
         XML (the same, in XML format) and
         <constant_name>pickle</constant_name> (which
         converts objects to a binary format and back, using
         a deep copy).
         </p>
         
         <p>
         There is more than one pickle protocol for
         serialization. As of Python 3.8, there are 6
         protocols. Higher versions of the python
         interpreter use higher pickle protocol versions by
         default. This means that pickles on one system are
         not necessarily fully compatible with other systems
         that use different protocol versions.
         </p>
         
         <p>
         Pickle cannot serialize lambda functions, and it
         cannot serialize many active objects like database
         connections and threads. Neither can json. Never
         unpickle from an untrusted source.
         </p>
         
         <pre><code class="language-python">import pickle

class A:
   number_ = 1
   string_ = "Hello World!"
   dict_ = { 'first':1, 'second':2 }
   list_ = [1, 2]
   tuple_ = (1, 2)

a = A()
pickled = pickle.dumps(a)
b = pickle.loads(pickled)
a.number_ = 2
print(b.number_)                             # b != a</pre></code>
         
         <p>
         <constant_name>dill</constant_name> is an
         alternative serializer that can serialize objects
         like nested functions and lambda functions. Dill
         can also serialize an entire interpreter session
         and subsequently reload it:
         </p>
         
         <pre><code class="language-python">import dill
dill.dump_session("10.pkl");
# dill.load_session("10.pkl");</pre></code>
         
         <p>
         To exclude an attribute from pickling, use
         <constant_name>__getstate__</constant_name>.
         <constant_name>__getstate__</constant_name> should
         copy the object's
         <constant_name>__dict__</constant_name> and remove
         any items for exclusion.
         Use <constant_name>__setstate__</constant_name> to
         restore the missing items.
         </p>
         
         <pre><code class="language-python">class A:
   def __init__(self):
      self.number_ = 1
      self.function_ = lambda x : (x + 1)
   
   #
   # Without this, pickle cannot serialize the above lambda
   # function.
   #
   
   def __getstate__(self):
      attributes = self.__dict__.copy()
      del attributes['function_']
      return attributes
   
   def __setstate__(self, deserialized_state):
      self.__dict__ = deserialized_state
      self.function_ = lambda x : (x + 1)

a = A()
pickled = pickle.dumps(a)
b = pickle.loads(pickled)
print(b.function_(1))                        #  2</pre></code>
         
         <p>
         json can also be used to serialize some objects:
         </p>
         
         <pre><code class="language-python">import json

class A:
   def __init__(self):
      self.number_ = 1
      self.string_ = "Hello World!"
      self.dict_ = { 'first':1, 'second':2 }
      self.list_ = [1, 2]
      self.tuple_ = (1, 2)

a = A()
a.number_ = 2

serialized = json.dumps(a.__dict__)
print(serialized)
b = A()
b.__dict__ = json.loads(serialized)
print(b.number_)                             #  2</pre></code>
         
         
         <h2>Licenses</h2>
         
         <p>
         
         All of the code in this repository (including in
         documentation and in README.md files and in HTML
         files) is licensed under the GNU General Public
         License, version 3. See
         <a href="https://www.gnu.org/licenses/">
            https://www.gnu.org/licenses/gpl-3.0.html
         </a>.
         
         </p>
         
         <p>
         
         All of the text in this repository (including in
         README.md files and in webpages) is licensed under
         the GNU Free Documentation License. See
         <a href="https://www.gnu.org/licenses/fdl-1.3.en.html">
            https://www.gnu.org/licenses/fdl-1.3.en.html
         </a>.
         
         </p>
         
         <p>
         
         The code snippets on this website can be found
         at
         <a href="https://github.com/j040222/object-oriented-python-tutorial/tree/main/code">
            https://github.com/j040222/object-oriented-python-tutorial/tree/main/code
         </a>.
         
         </p>
         
      </div>
   </body>
   
   <script>
      hljs.highlightAll();
   </script>
   
</html> 
